# Product Architecture

This document explains how NoteMarket is assembled across the Next.js frontend, Supabase backend, and supporting services. Use it when onboarding new engineers or planning architecture changes.

## High-Level Stack

- **Frontend**: Next.js 16 App Router, React 19, TypeScript, CSS Modules, and `lucide-react` icons.
- **Backend-as-a-Service**: Supabase for auth, Postgres tables, row-level security (RLS), and Storage.
- **Design System**: Custom Swiss Academic theme defined in `DESIGN_SYSTEM.md` and `src/app/globals.css`.
- **PDF Utilities**: `pdf-lib` for extracting metadata (page count, file size) client-side before uploads.

## Application Layout

```
src/
├─ app/             # App Router routes (home, search, sell, etc.)
├─ components/      # Reusable UI blocks (Header, DocumentCard, Toast, etc.)
├─ lib/             # Supabase client & shared data (universities, course codes)
└─ app/api (n/a)    # Reserved for future server routes if business logic moves server-side
```

- `src/app/layout.tsx` wires global fonts, `ToastProvider`, and the persistent `Footer`.
- Each route under `src/app/**/page.tsx` is currently a client component because it relies on browser-only APIs (`useState`, Supabase browser client, `useEffect`).

## Supabase Integration

### Client Usage

- `src/lib/supabase.ts` exposes `createClient()` via `@supabase/ssr`’s `createBrowserClient`.
- Every page that needs data (`home`, `search`, `document/[id]`, `sell`, `profile`, `login`) instantiates the client, performs queries with `.from('documents')`, `.auth`, or `.storage`.
- Environment variables:
  - `NEXT_PUBLIC_SUPABASE_URL`
  - `NEXT_PUBLIC_SUPABASE_ANON_KEY`

### Server Usage

- `src/app/auth/callback/route.ts` uses `createServerClient` with encrypted cookies to exchange Supabase OAuth codes for sessions. This is the only server-side Supabase call right now.

## Feature Flows

### Home (`/`)

1. `useEffect` runs `fetchDocuments()` on mount.
2. Query: latest 4 documents ordered by `created_at`.
3. Display via `DocumentCard`.

### Search (`/search`)

1. Fetch all documents once on mount.
2. Build filter lists (university/course/tags) via `useMemo`.
3. Client-side filtering + sorting; view toggles between grid/list.

### Sell (`/sell`)

1. On mount, check Supabase auth; redirect to `/login` if unauthenticated.
2. Users upload PDF → `pdf-lib` extracts metadata.
3. Upload file to `documents` bucket.
4. Insert metadata row into `documents` table (`title`, `course_code`, `university`, `price`, `page_count`, optional grade + proof URL).
5. Show `SuccessModal` and reset form.

### Document Detail (`/document/[id]`)

1. Fetch current user + document row by ID.
2. Determine ownership (`user.id === document.user_id`).
3. Request signed URL for PDF preview (`createSignedUrl` for 1 hour).
4. Render first page preview inside iframe with blur overlay for non-owners.
5. Owners can download via `supabase.storage.download` with filename generated by `generateDocumentFilename`.

### Profile (`/profile`)

1. Auth guard identical to `/sell`.
2. Fetch profile row + user documents.
3. Avatar upload uses public `avatars` bucket with `upsert: true`.
4. Saving sends `update` query to `profiles`.

### Auth (`/login` + `/auth/callback`)

- Email/password auth via `supabase.auth.signInWithPassword`.
- Sign-up collects username + full name, stored in `profiles` via trigger defined in `database/supabase_setup.sql`.
- After magic-link or OAuth, Supabase calls `/auth/callback?code=...`, server route exchanges the code and redirects to `/sell`.

## Storage Buckets

- `documents` (private): PDF files; access via signed URLs or direct download if policies allow.
- `avatars` (public): User avatars; files stored under `${user.id}/avatar.ext`.

## Toast & Feedback Layer

- `ToastProvider` wraps the entire tree so any component can call `useToast().showToast()`.
- `SuccessModal` is triggered on successful uploads to keep selling UX friendly.

## Future Considerations

- **Payments**: There is a placeholder button “Betaling kommer snart!” in `document/[id]/page.tsx`. Payment providers (Stripe, Vipps) will require server routes/webhooks.
- **Server Components**: Once Supabase queries move to RSC (or to API routes), we can reduce bundle size and secure secrets.
- **Search Scalability**: Currently client-only. For larger data sets, introduce server-side filtering or Supabase full-text search via RPC.
- **Caching**: No caching layer yet; each navigation triggers live Supabase reads.

Use this document to keep architecture discussions grounded and update it whenever you introduce new major components or services.

